Deepseek on 2024-12-30

> I am developing Python3 code for permanent scatterer interferometry. The code I have is estimating the velocity and residual height parameters as expected, but is rather slow. I think it could become faster with parallelization. Where do you think I should parellize the code? <<<class PSIParameterEstimator:
    def __init__(self,
                 wavelength: float,
                 temporal_baselines: np.ndarray,
                 perpendicular_baselines: np.ndarray,
                 range_distances: np.ndarray,
                 incidence_angles: np.ndarray):
        """
        Initialize PSI parameter estimator

        Parameters:
        -----------
        wavelength: float
            Radar wavelength in meters
        temporal_baselines: np.ndarray
            Time differences between master and slave images in days
        perpendicular_baselines: np.ndarray
            Perpendicular baselines in meters
        range_distances: np.ndarray
            Slant range distances in meters
        incidence_angles: np.ndarray
            Local incidence angles in radians
        """
        self.wavelength = wavelength
        self.temporal_baselines_years = temporal_baselines / 365.0 #Timo: temporal baselines need to be given in years
        self.perpendicular_baselines = perpendicular_baselines
        self.range_distances = range_distances
        self.incidence_angles = incidence_angles

    def estimate_parameters(self, phase_differences):
        """
        Estimates height error and velocity along network edges using periodogram approach.

        Args:
            phase_differences (ndarray): Complex phase differences between two PS points

        Returns:
            tuple: (height_error, velocity, temporal_coherence, residuals)
        """
        # Define search spaces for height error and velocity
        height_search = np.linspace(-100, 100, 200)  # meters, adjust range as needed
        velocity_search = np.linspace(-100, 100, 200)  # mm/year, adjust range as needed

        # Initialize coherence matrix
        coherence_matrix = np.zeros((len(height_search), len(velocity_search)))

        # Calculate constants for phase conversion
        height_to_phase = (4 * np.pi / self.wavelength) * (
                self.perpendicular_baselines / (self.range_distances * np.sin(self.incidence_angles))
        )
        velocity_to_phase = (4 * np.pi / self.wavelength) * self.temporal_baselines_years

        # Compute periodogram
        for i, h in enumerate(height_search):
            for j, v in enumerate(velocity_search):
                # Calculate model phases
                #phase_topo = h * height_to_phase
                #phase_motion = v * velocity_to_phase
                #model_phase = phase_topo + phase_motion
                phase_topo = np.angle(np.exp(1j * h * height_to_phase))
                phase_motion = np.angle(np.exp(1j * (v / 1000.0) * velocity_to_phase)) #Timo: velocity is given in mm
                model_phase = np.angle(np.exp(1j * (phase_topo + phase_motion)))

                # Calculate temporal coherence (equation 6.10)
                # temporal_coherence = np.abs(
                #     np.mean(
                #         np.exp(1j * np.angle(phase_differences)) *
                #         np.exp(-1j * model_phase)
                #     )
                # )

                #Timo: The np.angle of the phase difference seems to be a mistake as these are already given in radians
                temporal_coherence = np.abs(
                    np.mean(
                        np.exp(1j * phase_differences) *
                        np.exp(-1j * model_phase)
                    )
                )
                coherence_matrix[i, j] = temporal_coherence

        # Find maximum coherence
        max_idx = np.unravel_index(np.argmax(coherence_matrix), coherence_matrix.shape)
        best_height = height_search[max_idx[0]]
        best_velocity = velocity_search[max_idx[1]]
        max_coherence = coherence_matrix[max_idx]

        # Calculate residuals
        best_phase_topo = np.angle(np.exp(1j * best_height * height_to_phase))
        best_phase_motion = np.angle(np.exp(1j * (best_velocity / 1000) * velocity_to_phase))
        best_model_phase = np.angle(np.exp(1j * (best_phase_topo + best_phase_motion)))
        temporal_coherence2 = np.abs(
            np.mean(
                np.exp(1j * phase_differences) *
                np.exp(-1j * best_model_phase)
            )
        )
        # residuals = np.angle(
        #     np.exp(1j * np.angle(phase_differences)) *
        #     np.exp(-1j * model_phase)
        # )
        # Timo: The np.angle of the phase difference seems to be a mistake as these are already given in radians
        residuals = np.angle(
            np.exp(1j * phase_differences) *
            np.exp(-1j * best_model_phase)
        )

        return best_height, best_velocity, max_coherence


class ParameterEstimator:
    def __init__(self, ps_network):
        """
        Estimate parameters for entire PS network

        Parameters:
        -----------
        ps_network: dict
            Network information including edges and phase data
        """
        self.ps_info = ps_info
        self.points = ps_info['points']
        self.parameter_estimator = PSIParameterEstimator(
            wavelength=ps_network['wavelength'],
            temporal_baselines=ps_network['temporal_baselines'],
            perpendicular_baselines=ps_network['perpendicular_baselines'],
            range_distances=ps_network['range_distances'],
            incidence_angles=ps_network['incidence_angles']
        )

    def estimate_parameters(self, ref_point : int) -> dict:
        """
        Estimate parameters for all edges in the network

        Returns:
        --------
        network_parameters: dict
            Dictionary containing estimated parameters for each edge
        """
        parameters = {
            'height_errors': {},
            'velocities': {},
            'temporal_coherences': {}
        }

        ref_phases = self.points.iloc[ref_point][3:].to_numpy()
        for point_id in range(len(self.points)):
            if point_id != ref_point:
                phases = self.points.iloc[point_id][3:].to_numpy()
                phase_differences = np.angle(np.exp(1j * (ref_phases - phases)))
                height_error, velocity, temporal_coherence = (
                    self.parameter_estimator.estimate_parameters(
                        phase_differences
                    )
                )
                print(f'{point_id} / {len(self.points)} - {height_error},{velocity},{temporal_coherence}')

                parameters['height_errors'][point_id] = height_error
                parameters['velocities'][point_id] = velocity
                parameters['temporal_coherences'][point_id] = temporal_coherence
            else:
                parameters['height_errors'][point_id] = 0.0
                parameters['velocities'][point_id] = 0.0
                parameters['temporal_coherences'][point_id] = 1.0

        return parameters
>>>


To optimize your code, you can parallelize both the nested loops in `PSIParameterEstimator.estimate_parameters` and the loop in `ParameterEstimator.estimate_parameters`.

**Step 1: Parallelize the nested loops in `PSIParameterEstimator`**

Instead of using explicit Python loops, leverage NumPy's vectorization to compute the model phases for all height and velocity values simultaneously.

Modify the `estimate_parameters` method as follows:

```python
def estimate_parameters(self, phase_differences):
    """
    Estimates height error and velocity along network edges using periodogram approach.

    Args:
        phase_differences (ndarray): Complex phase differences between two PS points

    Returns:
        tuple: (height_error, velocity, temporal_coherence, residuals)
    """
    # Define search spaces for height error and velocity
    height_search = np.linspace(-100, 100, 200)  # meters, adjust range as needed
    velocity_search = np.linspace(-100, 100, 200)  # mm/year, adjust range as needed

    # Calculate constants for phase conversion
    height_to_phase = (4 * np.pi / self.wavelength) * (
            self.perpendicular_baselines / (self.range_distances * np.sin(self.incidence_angles))
    )
    velocity_to_phase = (4 * np.pi / self.wavelength) * self.temporal_baselines_years

    # Compute model phases using vectorized operations
    height_term = height_search[:, np.newaxis, np.newaxis] * height_to_phase[np.newaxis, :, :]
    velocity_term = (velocity_search[:, np.newaxis, np.newaxis] / 1000.0) * velocity_to_phase[np.newaxis, :, :]
    model_phases = height_term + velocity_term

    # Compute temporal coherence using vectorized operations
    exp_model_phases = np.exp(-1j * model_phases)
    exp_phase_differences = np.exp(1j * phase_differences)
    coherence = np.mean(exp_phase_differences[np.newaxis, :, :] * exp_model_phases, axis=2)
    coherence_matrix = np.abs(coherence)

    # Find maximum coherence
    max_coherence = np.max(coherence_matrix)
    best_height_idx, best_velocity_idx = np.unravel_index(np.argmax(coherence_matrix), coherence_matrix.shape)
    best_height = height_search[best_height_idx]
    best_velocity = velocity_search[best_velocity_idx]

    # Calculate residuals
    best_phase_topo = best_height * height_to_phase
    best_phase_motion = (best_velocity / 1000.0) * velocity_to_phase
    best_model_phase = best_phase_topo + best_phase_motion
    residuals = np.angle(np.exp(1j * phase_differences) * np.exp(-1j * best_model_phase))

    return best_height, best_velocity, max_coherence, residuals
```

**Step 2: Parallelize the loop in `ParameterEstimator.estimate_parameters`**

Use the `multiprocessing` module to parallelize the loop over `point_id`.

Modify the `ParameterEstimator` class as follows:

```python
from multiprocessing import Pool, cpu_count

class ParameterEstimator:
    def __init__(self, ps_network):
        """
        Estimate parameters for entire PS network

        Parameters:
        -----------
        ps_network: dict
            Network information including edges and phase data
        """
        self.ps_info = ps_info
        self.points = ps_info['points']
        self.parameter_estimator = PSIParameterEstimator(
            wavelength=ps_network['wavelength'],
            temporal_baselines=ps_network['temporal_baselines'],
            perpendicular_baselines=ps_network['perpendicular_baselines'],
            range_distances=ps_network['range_distances'],
            incidence_angles=ps_network['incidence_angles']
        )

    def _process_point(self, point_id, ref_point, ref_phases):
        if point_id != ref_point:
            phases = self.points.iloc[point_id][3:].to_numpy()
            phase_differences = np.angle(np.exp(1j * (ref_phases - phases)))
            height_error, velocity, temporal_coherence, _ = self.parameter_estimator.estimate_parameters(phase_differences)
            return point_id, height_error, velocity, temporal_coherence
        else:
            return point_id, 0.0, 0.0, 1.0

    def estimate_parameters(self, ref_point: int) -> dict:
        """
        Estimate parameters for all edges in the network

        Returns:
        --------
        network_parameters: dict
            Dictionary containing estimated parameters for each edge
        """
        parameters = {
            'height_errors': {},
            'velocities': {},
            'temporal_coherences': {}
        }

        ref_phases = self.points.iloc[ref_point][3:].to_numpy()

        # Parallel processing of points
        with Pool(processes=cpu_count()) as pool:
            results = pool.starmap(self._process_point, [(point_id, ref_point, ref_phases) for point_id in range(len(self.points))])

        for point_id, height_error, velocity, temporal_coherence in results:
            parameters['height_errors'][point_id] = height_error
            parameters['velocities'][point_id] = velocity
            parameters['temporal_coherences'][point_id] = temporal_coherence

        return parameters
```

**Explanation:**

- **Vectorization in `PSIParameterEstimator`:**
  - By using NumPy's broadcasting and vectorization, we compute the model phases and coherence for all height and velocity values simultaneously.
  - This eliminates the need for nested Python loops, which are slow, and leverages optimized C-level operations.

- **Parallelization in `ParameterEstimator`:**
  - We create a separate function `_process_point` that handles the computation for a single point.
  - We use a `Pool` of worker processes to process multiple points in parallel.
  - The `starmap` function applies `_process_point` to each `(point_id, ref_point, ref_phases)` tuple.
  - The results are collected and stored in the `parameters` dictionary.

**Additional Tips:**

- **Profiling:**
  - Use `cProfile` to profile your code and identify any remaining bottlenecks.
  - Example: `python -m cProfile -o output.prof script.py`

- **Sharing Data:**
  - Ensure that large arrays like `ref_phases` are shared efficiently between processes.
  - Consider using `multiprocessing.Array` or `shared_memory` for large datasets.

- **Thread Safety:**
  - Since each worker process handles a separate point independently, there should be no race conditions.
  - Avoid modifying shared data within worker processes.

- **Testing:**
  - Test the parallelized code with a small subset of data to ensure correctness.
  - Verify that the results match those of the original serial implementation.

By applying these optimizations, you should see a significant speedup in your code's performance.